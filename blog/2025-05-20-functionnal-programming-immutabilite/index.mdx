---
slug: functional-programming-immutabilite
title: prog fonct en java - immutabilit√©
authors: [adelegue]
tags: [patterns, java, prog-fonctionnelle]
---

Dans le post pr√©c√©dent, on a vu les fondations de la programmation fonctionnelle, ici, on va s'int√©resser plus en d√©tail √† l'immutabilit√© en java.

{/* truncate */}

## L'instant musical

<iframe width="560" height="315" src="https://www.youtube.com/embed/-1X73VmCj98?si=NxxgJSzWA5PvX7Yv" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Immutabilit√©

Une fa√ßon de ne pas gal√©rer avec les fonctions pures, c'est d'avoir des variables immutables. Mais comment √ßa se passe en java ?

Il existe le mot cl√© `final` qui permet d'assurer qu'une variable ne pourra pas √™tre r√©affect√©e.
Il peut √™tre utilis√© pour des variables, pour des attributs de classe et m√™me pour des param√®tres de m√©thode.
On peut √©galement l'utiliser lors de la d√©finition d'une classe pour s'assurer que la classe ne sera pas √©tendue.

### Les structures de donn√©es

Traditionnellement en java, on repr√©sente des structures de donn√©es par des `bean`.
Un bean d√©clare des attributs priv√©s mutables et propose des getters et des setters pour respectivement acc√©der aux attributs et modifier les attributs.

```java
public class User {

    private String nom;
    private String email;

    public String getNom() {
        return nom;
    }

    public void setNom(String nom) {
        this.nom = nom;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
```

En plus de la verbosit√©, ici, on est loins de l'immutabilit√© souhait√©e !

Une premi√®re approche serait de d√©clarer les attributs `final`, et tant qu'on y est, on va les d√©clarer `public`, comme √ßa, pas besoin de `getter`.

```java
public class User {

    public String nom;
    public String email;

    public User(String nom, String email) {
        this.nom = nom;
        this.email = email;
    }
}
```

On peut m√™me faire plus concis, en rempla√ßant la classe par un record :

```java
public record User(String nom, String email) {}
```

Les attributs du record sont immutables par d√©faut.

Avoir des structures immutables ajoute une certaine s√©curit√© et diminue la charge mentale lors du d√©veloppement mais, elle vient avec un certain nombre de contraintes.

Premi√®rement, comme il n'y a plus de setter, √ßa devient plus compliqu√© de modifier un attribut. Pour √ßa, on va devoir cr√©er une nouvelle instance :

```java
public record User(String nom, String email) {
    public User withNom(String nom) {
        return new User(nom, email);
    }
    public User withEmail(String email) {
        return new User(nom, email);
    }
}
```

Et donc, si on veut modifier l'email d'un user :

```java
var user = new User("Milo", "milo@gmail.com");
var userWithNameUpdated = user.withEmail("milo.aukerman@gmail.com");
```
Dans les futures versions de java, on devrait directment avoir le mot cl√© `with` :
```java
var user = new User("Milo", "milo@gmail.com");
var userWithNameUpdated = user with { email = "milo.aukerman@gmail.com" };
```
Mais il va falloir attendre un peu...


On peut vite se rendre compte que √ßa devient assez difficile de modifier la feuille d'une structure un peu plus compl√®xe :

```java
var userUpdated = user
        .withAddress(user.address
            .withCity(
                user.address.city.withZipCode("79000")
            )
        );
```
En programmation fonctionnelle, il existe ce qu'on appelle les optics pour modifier facilement des structures arborescentes (peut √™tre le sujet d'un article futur !). Malheureusement, il n'existe aucune impl√©mentation en java.


Nous venons de voir comment cr√©er nos propres structures immutables, mais que propose java en terme d'immutabilit√© dans le jdk ?

Un type de donn√©e tr√®s fr√©quemment utilis√©, ce sont les `java.util.List` et plus largement les collections.

### Les collections

La gestion de l'immutabilit√© dans l'API de collection n'est clairement pas au niveau.
Java propose des utilitaires pour v√©rrouiller des collections, mais pas vraiment d'outils pour pouvoir les modifier.

Il existe par exemple `Collections.unmodifiableList` :

```java
ArrayList<String> list = new ArrayList<>();
list.add("a");
List<String> immutableList = Collections.unmodifiableList(list);
immutableList.add("b");
```
üí•üß®üí£Ici, on va obtenir
```
java.lang.UnsupportedOperationException
	at java.base/java.util.Collections$UnmodifiableCollection.add(Collections.java:1091)
```

D'ailleurs, dans certains cas, ce sont directement des listes immutables qui sont cr√©√©es :

```java
List<String> immutableList = List.of("a");
immutableList.add("b");
```

M√™me r√©sultat :

```
java.lang.UnsupportedOperationException
	at java.base/java.util.Collections$UnmodifiableCollection.add(Collections.java:1091)
```

Perso, je trouve ce comportement assez angoissant, on ne sait jamais quand la manipulation d'une liste va nous p√©ter √† la gueule‚Ä¶

Dans le paragraphe pr√©c√©dent, quand on voulait modifier une structure, il fallait cr√©er une nouvelle instance avec la valeur modifi√©e.
Est-ce qu'on ne pourrait pas faire de m√™me avec les listes ?

Et bien la solution, c'est d'utiliser la syntaxe suivante :

```java
List<String> immutableList = List.of("a");
List<String> newList = Stream
    .concat(
        immutableList.stream(),
        Stream.of("b")
    )
    .toList();
```

√áa fonctionne, mais √ßa reste assez verbeux.

Quand on commence √† vraiment utiliser des collections immutables, l'API' de collections de la lib [`vavr`](https://vavr.io/) est largement au-dessus du jdk.

Vavr a port√© toute l'API de collection de scala en java et les collections propos√©es sont immutables par d√©faut :

```java
List<String> empty = List.empty();
List<String> unElement = empty.append("a");
List<String> deuxElements = unElement.append("b");
```
Ici, pas de mauvaises surprises ! Comme par exemple, des exceptions qui nous p√®tent √† la gueule.

#### Impacts de l'immutabilit√©

Comme pour les structures immutables, l'immutabilit√© dans les collections vient avec son lot de manipulations un peu tricky.

Un cas d'√©cole, incr√©menter un compteur en parcourant une liste :

```java
int i = 0;
for (String elt : list) {
    i = i + elt.length();
}
```

N'est plus possible en version immutable. Le code suivant ne compile plus :

```java
final int i = 0;
for (String elt : list) {
    i = i + elt.length();
}
```

Il faudra √©crire en java standard :

```java
Integer res = list.stream()
    .reduce(0, (acc, elt) ->  acc + elt.length(), Integer::sum);
```

Et √ßa avec vavr (pas besoin de g√©rer le cas de la parall√©lisation comme avec java std) :

```java
Integer res = list.foldLeft(0, (acc, elt) ->  acc + elt.length());
```

Sur plein d'aspect, l'API de collections de vavr permettra de g√©rer plus simplement tout un tas d'op√©rations.
Elle vient avec plein de m√©thodes out of box, contrairement au jdk :
* `find`, `distinct`, `distinctBy`, `groupBy` `max`, `count` ...

Les gatherer ont √©t√© introduits, dans la derni√®re version de java, √ßa rendra peut-√™tre l'utilisation native des collections plus utilisable.


